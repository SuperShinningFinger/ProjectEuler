# 编码题目总结

## EP01

### 题目

If we list all the natural numbers below 10 that are multiples of 3  or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.

### 思路

等差数列求和，result = sum3 + sum5 - sum15

### 代码

```c
#include <stdio.h>

#include <inttypes.h>

 

int main() {

    int sum3, sum5, sum15;

    sum3 = (3 + 999) * (999 / 3) / 2;

    sum5 = (5 + 995) * (995 / 5) / 2;

    sum15 = (15 + 990) * (990 / 15) / 2;

    printf("%d\n", sum3 + sum5 - sum15);

    return 0;

}
```





## EP02

### 题目

Each new term in the Fibonacci sequence is generated by adding the  previous two terms. By starting with 1 and 2, the first 10 terms will  be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do  not exceed four million, find the sum of the even-valued terms.

### 思路

Fibonacci数列可用两个变量计算

### 代码

```C
#include <stdio.h>

int main() {
    int ans = 0, a = 1, b = 2;
    while (b <= 4000000) {
        if (b % 2 == 0)
            ans += b;
        b = a + b;
        a = b - a;  //相当于 a + b - a
    }
    printf("%d\n", ans);
    return 0;
}
```





## EP03

### 题目

The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?

### 思路

从2开始不断除去大数的因子，每次循环去除一种，直至sqrt(n)，类似素数筛标记合数的思想。

### 代码

```c
#include <stdio.h>
#include <inttypes.h>
#define NUM 600851475143

int main() {
    int64_t num = NUM, n = 2, ans = 0;
    while (n * n <= num) {
        if (num % n == 0) ans = n;
        while (num % n == 0) num /= n;
        n += 1;
    }
    if (num != 1) ans = num;
    printf("%" PRId64 "\n", ans);
    return 0;
}
```





## EP04

### 题目

A palindromic number reads the same both ways. The largest palindrome  made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers.

### 思路

回文数判断如果数字小则可以直接求余乘10，公式为 num = num * 10 + x % 10

### 代码

```c
#include <stdio.h>

int is_palindromic(int x) {
    int temp = x, num = 0;
    while (x) {
        num = num * 10 + x % 10;
        x /= 10;
    }
    return temp == num;
}

int main() {
    int ans = 0;
    for (int i = 100; i < 1000; i++) {
        for (int j = i; j < 1000; j++) {
            if (i * j < ans) continue;
            if (!is_palindromic(i * j)) continue;
            ans = i * j;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```





## EP06

### 题目

The sum of the squares of the first ten natural numbers is,

12 + 22 + ... + 102 = 385

The square of the sum of the first ten natural numbers is,

(1 + 2 + ... + 10)2 = 552 = 3025

Hence the difference between the sum of the squares of the first ten  natural numbers and the square of the sum is 3025 − 385 = 2640.

Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

### 思路

平方和与和的平方的计算。和可用n(n+1)/2计算后再平方，平方和可用公式sum = n(n+1)(2*n+1)/6 计算

### 代码

```c
#include<stdio.h>


int main(){
    int sum1=5050,sum2=(100*(101)*(2*100+1))/6;    
    printf("%d",sum1*sum1-sum2);
    return 0;
}
```





## EP28

### 题目

Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:

**21** 22 23 24 **25**
 20  **7**  8  **9** 10
 19  6  **1**  2 11
 18  **5**  4  **3** 12
**17** 16 15 14 **13**

It can be verified that the sum of the numbers on the diagonals is 101.

What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?

### 思路

边长为n时，每圈的和可以用公式表示。sum = 4 * n * n -6 * n + 6.

### 代码

```c
#include<stdio.h>
int main(){
    int sum=1;
    for (int i=3;i<=1001;i+=2){
        sum+=4*i*i-6*i+6;
    }
    printf("%d",sum);
    return 0;
}
```





## EP30

### 题目

Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:

> 1634 = 1^4 + 6^4 + 3^4 + 4^4
>  8208 = 8^4 + 2^4 + 0^4 + 8^4
>  9474 = 9^4 + 4^4 + 7^4 + 4^4

As 1 = 1^4 is not a sum it is not included.

The sum of these numbers is 1634 + 8208 + 9474 = 19316.

Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.

### 思路

重点在于上界估计，即在什么时候不再会有结果。用函数表示等式左右两端的数字，设n为数字位数，左端为10^n，右端为9^5 * n

### 代码

```c
#include<stdio.h>
#include <math.h>
#define MAX_N 1000000
int main(){
    int ans=0;
    for (int i=2;i<MAX_N;i++){
        int temp=i,sum=0;
        while (temp){
            sum+=(int)pow(temp%10,5);
            temp/=10;
        }
        if (sum==i){
            ans+=i;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```





## EP34

### 题目

145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.

Find the sum of all numbers which are equal to the sum of the factorial of their digits.

Note: as 1! = 1 and 2! = 2 are not sums they are not included.

### 思路

与EP30一样，预估上界。位数为n，左端为10^n，右端为9! * n

### 代码

```c

#include<stdio.h>
#include <math.h>
#define MAX_N 1000000
int fac[10]={0};

int main(){
    for (int i=0;i<10;i++){
        int temp=1;
        for (int j=1;j<=i;j++){
           temp*=j;         
        }
        fac[i]=temp;
            
    }
    int ans=0;
    for (int i=3;i<MAX_N;i++){
        int temp=i,sum=0;
        while (temp){
            sum+=fac[temp%10];
            temp/=10;
        }
        if (sum==i){
            ans+=i;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```







## EP36

### 题目

The decimal number, 585 = 10010010012 (binary), is palindromic in both bases.

Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.

(Please note that the palindromic number, in either base, may not include leading zeros.)

### 思路

二进制与十进制都为回文数，回文判断可直接翻转数字，重点在于进制转换，掌握各种进制的回文翻转，进制的转换本质是位的权值变换，因此只要**改变进位乘数、求余、去位的因子**就能变换权值求值

### 代码

```c
#include<stdio.h>
#define MAX_N 1000000

int is_palindromic(int i,int n){
    int temp=i,sum=0;
    while (temp){
        sum = sum*n +temp%n;
        temp/=n;
    }
    if (i==sum) return 1;
    return 0;
}

int main(){
    int ans=0;
    for (int i=1;i<MAX_N;i++){
        if (is_palindromic(i,10)&&is_palindromic(i,2)){
            ans+=i;
        }
    }
    printf("%d\n",ans);
    return 0;
}

```







## EP05

### 题目

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

### 思路

求能被1~20整除的最小值，本质是找最小公倍数。因为有公式 ：数字 a，b的最小公倍数为c，最大公因子为gcd，则有  c = a * b / gcd(a,b)。

变为求最大公因子问题后，可用辗转相除法处理。

### 代码

```c
#include<stdio.h>
#include <inttypes.h>
int gcd(int a,int b){
    if (!b) return a;
    return gcd(b,a%b);
}


int main(){
    int64_t ans=1;
    for (int i=2;i<=20;i++){
        if (ans % i==0) continue;
        ans =ans *i/ gcd(ans,i);
    }
    printf("%"PRId64"\n",ans);
    return 0;
}
```





## EP07

### 题目

By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

What is the 10 001st prime number?

### 思路

求素数有两种方法，素数筛与线性筛。素数筛是用素数排除素数的倍数，线性筛是用列举常数乘以小于常数最小素因子的方法排除合数。都是标记数组的合数。时间复杂度上，素数筛为O(nloglongn)，线性筛为O(n)。

### 代码

#### 素数筛

```c
#include <stdio.h>
#define MAX_N 200000

int prime[MAX_N + 5] = {0};

void init() {
    for (int i = 2; i * i <= MAX_N; i++) {
        if (prime[i]) continue;
        for (int j = i * i; j <= MAX_N; j += i) {
            prime[j] = 1;
        }
    }
    for (int i = 2; i <= MAX_N; i++) {
        if (prime[i]) continue;
        prime[++prime[0]] = i;
    }
    return ;
} 

int main() {
    init();
    printf("%d\n", prime[10001]);
    return 0;
}
```

#### 线性筛

```c

#include<stdio.h>
#define MAX_N 10000
int is_prime[MAX_N+5]={0};
int prime[MAX_N+5]={0};
int main(){
    for (int M = 2;M<=MAX_N;M++){
        if (!is_prime[M]){
            prime[++prime[0]] = M;
        }
        for (int i=1,p=prime[1];i <= prime[0];i++,p=prime[i]){
            if (p*M >MAX_N) break;
            is_prime[p*M]=1;
            if (M%p==0) break;
//p必然小於等於M的最小素因子（否則p不可能爲i的最小素因子),所以M%p==0代表p爲M的最小素因子，再大必然越界
        }
    }
    for (int i=1;i<=prime[0];i++){
        printf("%d ",prime[i]);
    }
    printf("\n");
}
```





## EP08

### 题目

The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

 73167176531330624919225119674426574742355349194934
 96983520312774506326239578318016984801869478851843
 85861560789112949495459501737958331952853208805511
 12540698747158523863050715693290963295227443043557
 66896648950445244523161731856403098711121722383113
 62229893423380308135336276614282806444486645238749
 30358907296290491560440772390713810515859307960866
 70172427121883998797908792274921901699720888093776
 65727333001053367881220235421809751254540594752243
 52584907711670556013604839586446706324415722155397
 53697817977846174064955149290862569321978468622482
 83972241375657056057490261407972968652414535100474
 82166370484403199890008895243450658541227588666881
 16427171479924442928230863465674813919123162824586
 17866458359124566529476545682848912883142607690042
 24219022671055626321111109370544217506941658960408
 07198403850962455444362981230987879927244284909188
 84580156166097919133875499200524063689912560717606
 05886116467109405077541002256983155200055935729725
 71636269561882670428252483600823257530420752963450

Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

### 思路

滑动窗口法，每次往右移动一格，便去掉左端的一格。能直接运用的前提条件时增加操作与去左操作为逆操作，否则需要进行判断和特殊操作。如乘法与除法不是逆运算，需要判断除数是否为０．

以及大数据输入可用头文件与input处理。

### 代码

```C
#include<stdio.h>
#include "ep08.h"
#include <inttypes.h>

int main(){
    //read 1,000 bit data
    int64_t p=1,zero=0,ans=0;//zero计算區域中0的個數

    for (int i=0;num[i];i++){
       //右移
        if (num[i]=='0'){
            zero+=1;
        }else{
            p*=(num[i]-'0');
        }

        //去左的逆运算
        if (i>=13){
            if (num[i-13]=='0'){
                zero-=1;
            }else{
                p/=(num[i-13]-'0');
            }
        }

        //选定区域中没有0则更新
        if (zero==0&&p>ans) ans=p;
    }
    printf("%"PRId64"\n",ans);
    return 0;
}
```





## EP10

### 题目

The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million.

### 思路

就线性筛，每找到一个就加呗，结果可能过９位，用int64_t

### 代码

```ｃ
#include<stdio.h>
#include <inttypes.h>
#define MAX_N 2000000

int prime[MAX_N+5]={0};

int main(){
    int64_t sum=0;
    for (int i=2;i<=MAX_N;i++){
        if (!prime[i]){    
          prime[++prime[0]]=i;
          sum+=i;
        }
        for (int j=1;j<=prime[0]&&i*prime[j]<=MAX_N;j++){
            prime[i*prime[j]]=1;
            if (i%prime[j]==0) break;
        }
    }
    printf("%"PRId64"\n",sum);
    return 0;
}
```







## EP11

### 题目

In the 20×20 grid below, four numbers along a diagonal line have been marked in red.

 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
 32 98 81 28 64 23 67 10 **26** 38 40 67 59 54 70 66 18 38 64 70
 67 26 20 68 02 62 12 20 95 **63** 94 39 63 08 40 91 66 49 94 21
 24 55 58 05 66 73 99 26 97 17 **78** 78 96 83 14 88 34 89 63 72
 21 36 23 09 75 00 76 44 20 45 35 **14** 00 61 33 97 34 31 33 95
 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48

The product of these numbers is 26 × 63 × 78 × 14 = 1788696.

What is the greatest product of four adjacent numbers in the same  direction (up, down, left, right, or diagonally) in the 20×20 grid?

### 思路

方向数组的使用，循环定四层，前两层表示开始坐标ｘ，ｙ，第三层表示分别往ｋ个方向走，第四层表示走step步，每步的坐标可用 i +step * dir_arr表示。

### 代码

```c
#include<stdio.h>

int dir_arr[4][2]={
    1,1,
    1,-1,
    0,1,
    1,0
};
int main(){
    int num[30][30]={0};
    for (int i=5;i<25;i++){
        for (int j=5;j<25;j++){
            scanf("%d",num[i]+j);
        }
    }
    int ans=0;
    for (int x=5;x<25;x++){//遍歷每一個點
        for (int y=5;y<25;y++){//同上
            for (int k=0;k<4;k++){//往四個不同的方向走
                int p=1;
                for (int step=0;step<4;step++){//原地一步，走3步
                    int xx=x+step*dir_arr[k][0];
                    //x,y爲原位置step每次在k方向上多走step倍的一步（dir_arr代表一步），學會使用step*的方式每次新定義xx減少思考難度
                    int yy=y+step*dir_arr[k][1];
                    p*=num[xx][yy];
                }
                if (p>ans) ans=p;//更新ans
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```







## EP14

### 题目

The following iterative sequence is defined for the set of positive integers:

n → n/2 (n is even)
n → 3n + 1 (n is odd)

Using the rule above and starting with 13, we generate the following sequence:

13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1

It can be seen that this sequence (starting at 13 and finishing at 1)  contains 10 terms. Although it has not been proved yet (Collatz  Problem), it is thought that all starting numbers finish at 1.

Which starting number, under one million, produces the longest chain?

**NOTE:** Once the chain starts the terms are allowed to go above one million.

### 思路

记忆化搜索，用keep数组储存计算过的结果，从１开始算，之后的结果计算完成后储存到keep中再返回值。

### 代码

```C
#include<stdio.h>
#include <inttypes.h>
#define MAX_N 1000000
#define KEEP_RANGE 1000000

int keep_ans[KEEP_RANGE + 5]={0};//記憶化搜索，類dp

int get_length(int64_t x){
    if (x==1) return 1;//邊界1
    if (x<=KEEP_RANGE&&keep_ans[x]) return keep_ans[x];//已搜索,邊界2
    int temp_ans;
    //奇偶分別遞歸
    if (x&1) temp_ans =get_length(x*3+1)+1;//靈性+1
    else temp_ans=get_length(x>>1)+1;
    //遞歸結束後temp_ans爲結果，記錄結果
    if (x <= KEEP_RANGE) keep_ans[x]=temp_ans;
    //返回結果
    return temp_ans;
}

int main(){
    int ans=0,ans_length=0;
    for (int i=1;i<MAX_N;i++){//逐個判斷長度
        int temp_length = get_length(i);//獲取長度
        if (temp_length>ans_length){//更新長度
            ans = i;
            ans_length=temp_length;
        }
    }
    printf("%d(%d)\n",ans,ans_length);
    return 0;
}
```





## EP17

### 题目

If the numbers 1 to 5 are written out in words: one, two, three,  four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.

If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used? 

 

**NOTE:** Do not count spaces or hyphens. For  example, 342 (three hundred and forty-two) contains 23 letters and 115  (one hundred and fifteen) contains 20 letters. The use of "and" when  writing out numbers is in compliance with British usage.

### 思路

计算英文单词的字母数，有规律可循，重点在于怎么找规律，用if-else构建规律结果，用递归完成子问题的规律查找。前20的单词没有什么规律，之后的显而易见，所以构建两个数组。

### 代码

```C

#include<stdio.h>
 int num20[20]={0,3,3,5,4,
                4,3,5,5,4,
                3,6,6,8,8,
                7,7,9,8,8};
 int numten[10]={0,0,6,6,5,
                 5,5,7,6,6};
int getnum(int n){
 
    if (n<20) return num20[n];
    if (n<100) return numten[n/10]+num20[n%10];
    if (n<1000){
        if (n%100==0)
        return num20[n/100]+7;
        else
         return getnum(n%100)+num20[n/100]+10;
    }
    if (n==1000) return 11;
}
int main(){
    int sum=0;   
    for (int i=1;i<=1000;i++){
        sum+=getnum(i);
    }
    printf("%d\n",sum);
    return 0; 
}
```





## EP13

### 题目

Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.

 37107287533902102798797998220837590246510135740250
 46376937677490009712648124896970078050417018260538
 74324986199524741059474233309513058123726617309629
 91942213363574161572522430563301811072406154908250
 23067588207539346171171980310421047513778063246676
 89261670696623633820136378418383684178734361726757
 28112879812849979408065481931592621691275889832738
 44274228917432520321923589422876796487670272189318
 47451445736001306439091167216856844588711603153276
 70386486105843025439939619828917593665686757934951
 62176457141856560629502157223196586755079324193331
 64906352462741904929101432445813822663347944758178
 92575867718337217661963751590579239728245598838407
 58203565325359399008402633568948830189458628227828
 80181199384826282014278194139940567587151170094390
 35398664372827112653829987240784473053190104293586
 86515506006295864861532075273371959191420517255829
 71693888707715466499115593487603532921714970056938
 54370070576826684624621495650076471787294438377604
 53282654108756828443191190634694037855217779295145
 36123272525000296071075082563815656710885258350721
 45876576172410976447339110607218265236877223636045
 17423706905851860660448207621209813287860733969412
 81142660418086830619328460811191061556940512689692
 51934325451728388641918047049293215058642563049483
 62467221648435076201727918039944693004732956340691
 15732444386908125794514089057706229429197107928209
 55037687525678773091862540744969844508330393682126
 18336384825330154686196124348767681297534375946515
 80386287592878490201521685554828717201219257766954
 78182833757993103614740356856449095527097864797581
 16726320100436897842553539920931837441497806860984
 48403098129077791799088218795327364475675590848030
 87086987551392711854517078544161852424320693150332
 59959406895756536782107074926966537676326235447210
 69793950679652694742597709739166693763042633987085
 41052684708299085211399427365734116182760315001271
 65378607361501080857009149939512557028198746004375
 35829035317434717326932123578154982629742552737307
 94953759765105305946966067683156574377167401875275
 88902802571733229619176668713819931811048770190271
 25267680276078003013678680992525463401061632866526
 36270218540497705585629946580636237993140746255962
 24074486908231174977792365466257246923322810917141
 91430288197103288597806669760892938638285025333403
 34413065578016127815921815005561868836468420090470
 23053081172816430487623791969842487255036638784583
 11487696932154902810424020138335124462181441773470
 63783299490636259666498587618221225225512486764533
 67720186971698544312419572409913959008952310058822
 95548255300263520781532296796249481641953868218774
 76085327132285723110424803456124867697064507995236
 37774242535411291684276865538926205024910326572967
 23701913275725675285653248258265463092207058596522
 29798860272258331913126375147341994889534765745501
 18495701454879288984856827726077713721403798879715
 38298203783031473527721580348144513491373226651381
 34829543829199918180278916522431027392251122869539
 40957953066405232632538044100059654939159879593635
 29746152185502371307642255121183693803580388584903
 41698116222072977186158236678424689157993532961922
 62467957194401269043877107275048102390895523597457
 23189706772547915061505504953922979530901129967519
 86188088225875314529584099251203829009407770775672
 11306739708304724483816533873502340845647058077308
 82959174767140363198008187129011875491310547126581
 97623331044818386269515456334926366572897563400500
 42846280183517070527831839425882145521227251250327
 55121603546981200581762165212827652751691296897789
 32238195734329339946437501907836945765883352399886
 75506164965184775180738168837861091527357929701337
 62177842752192623401942399639168044983993173312731
 32924185707147349566916674687634660915035914677504
 99518671430235219628894890102423325116913619626622
 73267460800591547471830798392868535206946944540724
 76841822524674417161514036427982273348055556214818
 97142617910342598647204516893989422179826088076852
 87783646182799346313767754307809363333018982642090
 10848802521674670883215120185883543223812876952786
 71329612474782464538636993009049310363619763878039
 62184073572399794223406235393808339651327408011116
 66627891981488087797941876876144230030984490851411
 60661826293682836764744779239180335110989069790714
 85786944089552990653640447425576083659976645795096
 66024396409905389607120198219976047599490197230297
 64913982680032973156037120041377903785566085089252
 16730939319872750275468906903707539413042652315011
 94809377245048795150954100921645863754710598436791
 78639167021187492431995700641917969777599028300699
 15368713711936614952811305876380278410754449733078
 40789923115535562561142322423255033685442488917353
 44889911501440648020369068063960672322193204149535
 41503128880339536053299340368006977710650566631954
 81234880673210146739058568557934581403627822703280
 82616570773948327592232845941706525094512325230608
 22918802058777319719839450180888072429661980811197
 77158542502016545090413245809786882778948721859617
 72107838435069186155435662884062257473692284509516
 20849603980134001723930671666823555245252804609722
 53503534226472524250874054075591789781264330331690

### 思路

计算100个50位数和的前10位。大数计算之加法计算，乘法每算一次进一次位，加法可以全部加完再进位。所以用乘法模板较有适用性。进位处理熟练掌握。

### 代码

```c
#include<stdio.h>
#include<string.h>

char num[55];
int ans[55]={1,0};

//大整數第0位記錄長度
int main(){
    for (int i=0;i<100;i++){
        scanf("%s",num);
        int len=strlen(num);
        if (ans[0]<strlen(num)) ans[0]=len;
        for (int j=0;j<len;j++){
            ans[len-j]+=(num[j]-'0');
        }
        for (int j = 1; j<=ans[0];j++){//進位處理，通用模板記住記住記住，可用於乘法
            if (ans[j]<10) continue;
            //以下代碼都是發生進位的處理
            ans[j+1]+=ans[j]/10;
            ans[j]%=10;
            ans[0] += (j==ans[0]);
            //已經進位，必然有j+1位，如果有j==ans[0]，則長度+1,用bool表示+1,絕了
        }
    } 
    for (int i = ans[0];i>ans[0]-10;i--){
        printf("%d",ans[i]);
    }
    printf("\n");
    return 0;
}
```





## EP25

### 题目

The Fibonacci sequence is defined by the recurrence relation:

> F*n* = F*n*−1 + F*n*−2, where F1 = 1 and F2 = 1.

Hence the first 12 terms will be:

> F1 = 1
>  F2 = 1
>  F3 = 2
>  F4 = 3
>  F5 = 5
>  F6 = 8
>  F7 = 13
>  F8 = 21
>  F9 = 34
>  F10 = 55
>  F11 = 89
>  F12 = 144

The 12th term, F12, is the first term to contain three digits.

What is the index of the first term in the Fibonacci sequence to contain 1000 digits?

### 思路

求第一个有1000位的Fibonacci数列。还是大数相加，但是和三个大数有关，所以可以用一个３行的二维数组表示三个大数。用**循环数组**节省空间，利用求余进行循环。可用３个指针指向３行数组减少编程复杂度。

### 代码

```c

#include<stdio.h>
//循环数组与大数相加
int fib[3][1005] = {{0,0},{1,1},{1,1}};//用三个数组表示fib求解的三个变量
//fib[1] add fib[2] to fib[0] at first
int n = 2;//从最后一个开始循环这样才能在下一个回到fib[0]
int main(){
    while (fib[n%3][0]<1000){
        n++;
        int *a =fib[n%3],*b=fib[(n-1)%3],*c=fib[(n-2)%3];

        for (int i=1;i<=b[0];i++){//b[0]比c[0]大
            a[i]=b[i]+c[i];
        }
        a[0]=b[0];
        for (int i=1;i<=a[0];i++){
            if (a[i]<10) continue;
            a[i+1]+=a[i]/10;
            a[i]=a[i]%10;
            a[0]+=(i==a[0]);
        }
                            
    }
    printf("%d\n",n);
    return 0;
}
```





## EP31

### 题目

In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:

> 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).

It is possible to make £2 in the following way:

> 1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p

How many different ways can £2 be made using any number of coins?

###　思路

半步DP实力，出现递推思想。可降维，初始化dp[ 0 ] = 1。

### 代码

```c
#include<stdio.h>
#define MAX_W 8

int w[MAX_W]={1,2,5,10,20,50,100,200};
int dp[201]={0};

int main(){
    dp[0]=1;
    for (int i=0;i<8;i++){
        for (int j=w[i];j<201;j++){
            dp[j]+=dp[j-w[i]];
        }
    }
    printf("%d\n",dp[200]);
    return 0;
}
```

 



## EP32

### 题目

We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.

The product 7254 is unusual, as the identity, 39 × 186 = 7254,  containing multiplicand, multiplier, and product is 1 through 9  pandigital.

Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.

HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.

### 思路

全排列题。难点在于边界的确定与是否达到９位的判断，边界用位数相加小于等于９判断，在位数之和达到９位之前直接continue。

### 代码

```c

#include<stdio.h>
#include <math.h>

int used[100000]={0};

int digit(int x){
    return floor(log10(x))+1;
}


int set_one(int x,int *num){
    while (x){
        if (num[x%10]) return 0;
        if (x%10==0) return 0;
        num[x%10] = 1;
        x/=10;
    }
    return 1;
}

int judge(int i,int j,int sum){
    int num[10]={0};
    if (!set_one(i,num)) return 0;
    if (!set_one(j,num)) return 0;   
    if (!set_one(i*j,num)) return 0;
    return 1;
}

int main(){
    int sum=0;
    for (int i=2;digit(i)*2+digit(i*i)<=9;i++){
        for (int j=i+1;digit(i)+digit(j)+digit(i*j)<=9;j++){
            if (digit(i)+digit(j)+digit(i*j)<9) continue;
            if (judge(i,j,i*j)){
                if (used[i*j]==0){
                    sum+=i*j;
                    used[i*j]=1;
                }
            }
        }
    }
    printf("%d\n",sum);
    return 0;
}
```





## EP33

### 题目

The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.

We shall consider fractions like, 30/50 = 3/5, to be trivial examples.

There are exactly four non-trivial examples of this type of fraction,  less than one in value, and containing two digits in the numerator and  denominator.

If the product of these four fractions is given in its lowest common terms, find the value of the denominator.

### 思路

分数性质题。ａ / b = c / d，得出a * d = b * c。将除法转为乘法，各个位数存在变量中，进行计算后得出答案。

另外分数化为最简形式可以用最大公因数。每计算一次，除以最大公因数一次。

### 代码

```c

#include<stdio.h>
#include <inttypes.h>
int64_t gcd(int64_t a,int64_t b){
    if (!b) return a;
    return gcd(b,a%b);
}

int is_trival(int64_t i,int64_t j){
    int x1=i/10,y1=i%10,x2=j/10,y2=j%10;
    if (!x1||!y1||!x2||!y2) return 0;
    if (x1==x2&&y1*j==y2*i) return 1;
    //判断一个分数是否为另一个分数的约分结果，即判断两个结果是否相等，用交叉相乘可化为乘法等式
    if (x1==y2&&y1*j==x2*i) return 1;
    if (x2==y1&&x1*j==y2*i) return 1; 
    if (y2==y1&&x1*j==x2*i) return 1;
    return 0;
}

int main(){
    int64_t sumi=1,sumj=1;
    for (int i=10;i<100;i++){
        for (int j=i+1;j<100;j++){
            if (!is_trival(i,j)) continue;//过滤型写法
            printf("i=%d,j=%d\n",i,j);
            sumi*=i;
            sumj*=j;
            int64_t temp=gcd(sumi,sumj);
         //每次都进行约分确保数字不越界，用temp保存，否则结果会在sumj/=gcd(sumi,sumj)变化
            sumi/=temp;
            sumj/=temp;
            printf("sumi=%lld,sumj=%lld\n",sumi,sumj);
        }
    }
    printf("%"PRId64"\n",sumj);
    return 0;
}
```

 



## EP35

### 题目

The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.

There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.

How many circular primes are there below one million?

### 思路

线性筛打出素数集，数字的循环移动可以用右移实现，即先去尾，将尾部的数乘以最高位的权值加回来。

### 代码

```c
#include<stdio.h>
#include <math.h>
#define MAX_N 1000000



//重点在于将数字循环右移的方法，利用log10函数求出数字位数，用数字位数进行循环和最高位赋值，掌握log10求位数的思想



int prime[MAX_N+5]={0};
int is_prime[MAX_N+5]={0};

int is_circular(int x){
    if (is_prime[x]) return 0;
    //整体右移
    int j=(int)floor(log10(x))+1,n=x,h=(int)pow(10,floor(log10(n)));
    for (int i=0;i<j;i++){//j为位数（即右移次数）
        x=x/10+(x%10)*h;//整体右移，去掉最后一位（x/10），将其放在最高位,floor(log10(n))为当前最高位是第几位
        if (is_prime[x]) return 0;
    }
    return 1;
}


int main(){
    int ans=0;
    //线性筛
    for (int i=2;i<=MAX_N;i++){
        if (!prime[i]){
            prime[++prime[0]]=i;
        }
        for (int j=1;j<=prime[0]&&i*prime[j]<=MAX_N;j++){
            is_prime[i*prime[j]]=1;
            if (i%prime[j]==0) break;//别忘了！！
         }
    }

    for (int i=2;i<=MAX_N;i++){
        if (is_circular(i)) 
            ans++;
    }
    
    printf("%d\n",ans);
    return 0;
}
```





## EP37

### 题目

The number 3797 has an interesting property. Being prime itself, it  is possible to continuously remove digits from left to right, and remain  prime at each stage: 3797, 797, 97, and 7. Similarly we can work from  right to left: 3797, 379, 37, and 3.

Find the sum of the only eleven primes that are both truncatable from left to right and right to left.

NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.

### 思路

与EP35类似，先打线性筛。之后先去尾判断，再去头判断。重点在于去头时如何**计算最高位的数字**。先求出最高位权值ｐ，用num/p求最高位数字。

### 代码

```c

#include<stdio.h>
#include <math.h>
#define MAX_N 1000000

int prime[MAX_N]={0};
int is_prime[MAX_N]={1,1};

int is_truncatable(int x){
    int temp=x;
    while (temp){
        if (is_prime[temp]) return 0;
        temp/=10;
    }
    temp=x;
    int n=pow(10,(int)floor(log10(temp)));
    while (temp){
        if (is_prime[temp]) return 0;
        temp-=(temp/n)*n;//最关键点在于使用temp/n表示最高位的数字
        n/=10;
    }
    return 1;
}

int main(){
    int count=0,sum=0;
    for (int i=2;i<=MAX_N;i++){
        if (!is_prime[i]) prime[++prime[0]]=i;
        for (int j=1;j<=prime[0]&&i*prime[j]<=MAX_N;j++){
            is_prime[i*prime[j]]=1;
            if (i%prime[j]==0) break;
        }
    }

    for (int i=5;count<11;i++){
        if (is_truncatable(prime[i])){
            sum+=prime[i];
            printf("%d=%d\n",count,prime[i]);
            count++;
        }
    }
    printf("%d\n",sum);
    return 0;
}
```





## EP38

### 题目

Take the number 192 and multiply it by each of 1, 2, and 3:

> 192 × 1 = 192
>  192 × 2 = 384
>  192 × 3 = 576

By concatenating each product we get the 1 to 9 pandigital,  192384576. We will call 192384576 the concatenated product of 192 and  (1,2,3)

The same can be achieved by starting with 9 and multiplying by 1, 2,  3, 4, and 5, giving the pandigital, 918273645, which is the concatenated  product of 9 and (1,2,3,4,5).

What is the largest 1 to 9 pandigital 9-digit number that can be  formed as the concatenated product of an integer with (1,2, ... , n) where n > 1?

### 思路

全数字问题。注意主函数尽量简单，复杂的任务留到函数完成，判断函数如果不符合返回０，否则返回得出的值。循环判断时注意位数，只有９位才符合要求。**do-while 部分不熟练，记得复习**

### 代码

```c

#include<stdio.h>
#include <math.h>

int is_valid(int x){
    int num[10]={0};//判断位数数组
    int n=0,digit=0;//n为相乘的倍数（1-9），digit代表当前乘积结果的位数
    do{
        n++;//从1开始
        int y= x*n;//每次乘n
        while (y){//填写num数组
            if (y%10==0) return 0;
            if (num[y%10]) return 0;
            num[y%10]=1;
            y/=10;
            digit++;//填写成功，位数+1
        }
    }while(digit<9);
    if (digit>9) return 0;//如果填写位数过多,其实根本不存在=。=
    int ret=0;//结果计算，用计算过的倍数n还原
    for (int i=1;i<=n;i++){
        int y=x*i;
        ret=ret*(int)pow(10,floor(log10(y))+1)+y;
    }
    return ret;
}

int main(){
    int ans=0;
    for (int i=1;i<10000;i++){//最多不超过5位数，因为至少两个等式，所以5位数*2必然超过9位
        int temp=is_valid(i);//判断i是否符合符合返回值，否则返回0
        if (temp>ans) ans=temp;//更新
        temp&&printf("%d* (1,2,3,...)=%d\n",i,temp);
    }
    printf("%d\n",ans);

    return 0;
}
```





## EP43

### 题目

The number, 1406357289, is a 0 to 9 pandigital number because it is  made up of each of the digits 0 to 9 in some order, but it also has a  rather interesting sub-string divisibility property.

Let *d*1 be the 1st digit, *d*2 be the 2nd digit, and so on. In this way, we note the following:

- *d*2*d*3*d*4=406 is divisible by 2
- *d*3*d*4*d*5=063 is divisible by 3
- *d*4*d*5*d*6=635 is divisible by 5
- *d*5*d*6*d*7=357 is divisible by 7
- *d*6*d*7*d*8=572 is divisible by 11
- *d*7*d*8*d*9=728 is divisible by 13
- *d*8*d*9*d*10=289 is divisible by 17

Find the sum of all 0 to 9 pandigital numbers with this property.

### 思路

全排列问题。用C++的STL可以遍历全排列，在<algorithm>里的prev_permutation与next_permutation函数。

### 代码

```c

#include<stdio.h>
#include <inttypes.h>


#include <algorithm>

using namespace std;
//船新全排列函数，prev_permutation（前一个排列）,next_permutation（后一个排列），顺序默认升序

void show_num(int *num){
    for (int i=0;i<10;i++){
        printf("%d",num[i]);
    }
    printf("\n");

}
int64_t is_interesting(int *num){
    if (num[0]==0) return 0;
    int prime[7]={2,3,5,7,11,13,17};
    int64_t sum=num[0],ans=num[0];
    for (int i=1,j=0;i<10;i++){
        ans=ans*10+num[i];
        sum=sum*10+num[i];//更习惯去使用统一格式计算然后特殊处理的方式代码
        if (i<3) continue;
        sum-=1000*num[i-3];
        if (sum%prime[j++]) return 0;
    /*不美观 
     *  if (i<=7){    
           sum=num[i]*100+num[i+1]*10+num[i+2];
           if (sum%prime[j++]!=0) return 0;
        }
     */
    }
    printf("ans=%"PRId64"\n",ans);
    return ans;
}


int main(){
    int num[10]={0,1,2,3,4,5,6,7,8,9};
    int64_t sum=0;
    do{
        sum+=is_interesting(num);//尽量使用简单的函数名完成功能，减少main函数逻辑难度
    }while (next_permutation(num,num+10));//从num到num+10位置统一全排列，记住函数
    printf("%"PRId64"\n",sum);
    return 0;
}
```





## EP44

### 题目

Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?

### 思路

用**二分法**找到符合条件的ｎ。**循环边界**是动态计算得出的。边界是相邻两个五边形数的差大于当前答案，因为五边形数时三次函数，增长速度不断变快，因此之后都不可能比当前答案小了。注意：需要定两个变量，一个记录最后位置，一个从后往前找

### 代码

```c

#include<stdio.h>
#include <stdlib.h>
#include <inttypes.h>


int64_t pentagonal(int64_t x){
    return x*(3*x-1)/2;
}

int64_t binary_search(int64_t (*fun)(int64_t),int64_t n,int64_t key){
    int64_t head=0,tail=n-1,mid;
    while (head<=tail){
        mid = (head + tail) / 2;
        if (fun(mid) == key) return mid;
        if (key < fun(mid)) tail = mid -1;
        else head = mid + 1;
    }
    return 0;
}

int main(){
    int64_t ans = INT64_MAX;
    int64_t i=2,j=i-1;
    while (pentagonal(i)-pentagonal(i-1)<ans){ 
        i++;
        j = i - 1;
        do{
            if (binary_search(pentagonal,INT32_MAX,pentagonal(i)+pentagonal(j))){
                if (binary_search(pentagonal,INT32_MAX,pentagonal(i)-pentagonal(j))){
                    if (ans > pentagonal(i) - pentagonal(j)){
                        ans = pentagonal(i) - pentagonal(j);
                     }
                 }
             }
            j--;
        } while (j>=1 && pentagonal(i)-pentagonal(j) < ans);
    }
    printf("%"PRId64"\n",ans);

    return 0;
}
```





## EP45

### 题目

Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

| Triangle   |      | T*n*=*n*(*n*+1)/2  |      | 1, 3, 6, 10, 15, ...  |
| ---------- | ---- | ------------------ | ---- | --------------------- |
| Pentagonal |      | P*n*=*n*(3*n*−1)/2 |      | 1, 5, 12, 22, 35, ... |
| Hexagonal  |      | H*n*=*n*(2*n*−1)   |      | 1, 6, 15, 28, 45, ... |

It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.

### 思路

六边形数跨度大，比较次数少，所以从六边形数开始循环，找到符合条件的另两个数。因为所有的六边形数都是三边形数，所以只要判断六边形数是否为五边形数就可以了。有两个函数的二分查找，可以用函数传参的方式减少代码量。

###　代码

```c

#include<stdio.h>
#include <inttypes.h>
//用函数传参完成C语言的多态（类似,数组也可以）   返回值 （*函数名）（参数类型），重要
//任意一个六边形数都是三边形数（2*n-1==m）
//将函数视作大数组的思想，结合二分查找
int64_t Pentagonal(int64_t n){
    return n*(3*n-1)/2;
}


int64_t Hexgonal(int64_t n){
    return n*(2*n-1);
}

int binary_search(int64_t (*num)(int64_t),int64_t n,int64_t x){//二分查找通用框架
    int head=0,tail=n-1,mid;
    while (head<=tail){
        mid=(head+tail)>>1;
        if (num(mid)==x) return mid;
        if (num(mid)<x) head=mid+1;
        else tail=mid-1;
    }
    return -1;
}

int main(){
    int n=144;    
    while (binary_search(Pentagonal,2*n,Hexgonal(n))==-1) n++;
    printf("%"PRId64"\n",Hexgonal(n));
    return 0;
}
```





## EP09

### 题目　

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

 a2 + b2 = c2

For example, 32 + 42 = 9 + 16 = 25 = 52.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.

### 思路

素勾股数问题。有数学性质4条：

1. 勾股数的倍数依然是勾股数；

2. 素勾股数之间两两互质；

3. 有a^2 + b^2 = c^2，ａ与ｂ必定一奇一偶；

4. 素勾股数可表达为以下形式：有 n<m，gcd(m,n)=1，则

   a = 2 * n * m

   b = m^2 - n^2

   c = m^2 + n^2

解决问题时可以先求出素勾股数再求倍数得出目标勾股数。

### 代码

```c

#include <stdio.h>

#include <stdlib.h>

#include <math.h>

 

 int main() {
     int flag=1;
     for (int i=1;i<16&&flag;i++){//边界条件的确定由 a+b+c=2*i*j+2*j*j<=1000，在i==j的情况下i大约在sqrt(250)内，即16内，j同理
         for (int j=i+1;j<=16&&flag;j++){
             int a=2*i*j;
             int b=j*j-i*i;
             int c=i*i+j*j;
             if (1000 % (a + b +c) == 0){
                int e=pow(1000/(a+b+c),3);//求出满足条件的素勾股数，求出倍数相乘
                printf("%d\n",e*a*b*c);
                flag=0;
             }
         }
     }

     return 0;


```





## EP12

### 题目

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

>  **1**: 1
>  **3**: 1,3
>  **6**: 1,2,3,6
> **10**: 1,2,5,10
> **15**: 1,3,5,15
> **21**: 1,3,7,21
> **28**: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

### 思路

表示三角形数的因数个数。三角形数可以用n(n+1)/2表示。一个数x若可以拆成ａ * b且gcd(a,b)=1，则x的因子数为a的因子数乘以b的因子数。因为n与n+1必然互质，所以n为偶数时，n/2与ｎ+1互质；n为奇数时，(n+1)/2与n互质。因此只需打表求出值为因子数的数组即可求出三角形数的因子数。

求一个数的因子数，可将一个数字拆为(a^m)(b^n)....，因子数为(m+1)*(n+1)....因此可以将这个数的**最小素因子**的次方存在数组中。因为使用线性筛框架，所以**找到最小素因子时就会进入下一层打表**，所以记录最小素因子足够。

打因子数表可以用**线性筛框架**。素数的因子数为２，数字n的因子数存在dnum[n]中，最小素因子的次方数存在mnum[n]中。

明白如何求三角形数的因子数后，问题就变成求一个范围内所有数的因子数。

### 代码

```c

#include<stdio.h>
#define MAX_N 1000000

int mnum[MAX_N+5]={0};//拆解时作为指数的次数
int dnum[MAX_N+5]={0};//对应数字的因子数
int prime[MAX_N+5]={0};//线性筛数组

//重点在于mnum数组的理解，mnum数组其实是不断刷新的指数，表示i*prime[j]情况下prime[j]的的次数（因为线性筛框架所以所有数只处理一次）,如在12在线性筛里被拆为i=6,prime[j]=2,所以mnum所代表数为2的指数为mnum[6]+1

void init(){
    for (int i=2;i*2<=MAX_N;i++){
        if (!prime[i]){
            prime[++prime[0]]=i;
            dnum[i]=2;
            mnum[i]=1;//素数有两个因子，指数为1
        }
        for (int j=1;j<=prime[0];j++){
            if (i*prime[j]>MAX_N) break;
            prime[i*prime[j]]=1;
            if (i%prime[j]==0){//i中已经有了prime[j]因子
                mnum[i*prime[j]]=mnum[i]+1;//i中prime[j]因子的次数+1得出i*prime[j]的次数
                               dnum[i*prime[j]]=dnum[i]/(mnum[i]+1)*(mnum[i]+2);
                break;
            }else{
                mnum[i*prime[j]]=1;
                dnum[i*prime[j]]=dnum[i]*dnum[prime[j]];
            }
        }
    }
    return;
}

int factor_nums(int n){//三边形公式 n*(n+1)/2，分奇偶讨论，因子数为两个数（必然互质）相乘
    if (n&1){
        return dnum[n]*dnum[(n+1)/2];
    }
    return dnum[n/2]*dnum[n+1];
}


int main(){
    init();//数组初始化
    int n=1;
    while (factor_nums(n)<500) n++;//计算三边形数的因子数
    printf("%d\n",n*(n+1)/2);


    return 0;
}
```





## EP15

### 题目

Starting in the top left corner of a 2×2 grid, and only being able to  move to the right and down, there are exactly 6 routes to the bottom  right corner.

 ![img](https://projecteuler.net/project/images/p015.gif)

How many such routes are there through a 20×20 grid?

### 思路

将路径问题转为行动序列。向右走用Ｒ表示，向下走用Ｄ表示，则每种情况可以用不同的Ｒ与Ｄ组合表示。当格子为2 x 2时，走四步到达终点。则序列可以表示为RRDD,RDRD,RDDR,DRRD,DRDR,DDRR。所以问题就变为从４个步骤中选出两个Ｒ或Ｄ，即C42。所以20 x 20的答案为C4020。计算时可以没乘一个便除一个，以免越界。

也可以用DP做。

### 代码

```c

#include<stdio.h>
#include <inttypes.h>

int main(){
    int64_t ans = 1;
    for (int i = 21,j = 1; i <= 40 && j <= 20; i++,j++){
        ans =ans * i / j;
    }
    printf("%"PRId64"\n",ans);
    return 0;
}
```





## EP16

### 题目

2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.

What is the sum of the digits of the number 2^1000?

### 思路

大整数乘法。可用快速幂简化。也可以每次乘的幂次增加减少循环。

### 代码

```c

#include<stdio.h>
#define DIGIT 400 //位数估算，2^10=1024约为10^3，2^1000约为10^300，大概300位

int num[DIGIT]={1,1};//这样初始化只会将0,1位置置为1;
//可用快速幂
int main(){
    int sum=0;
    for (int i=0;i<50;i++){//将i的循环次数减少，则将每次*2改为每次*2^20
        for (int j=1;j<=num[0];j++){
            num[j]*=1024*1024;//每次*2^20
        }
        for (int j=1;j<=num[0];j++){//标准进位处理
             if (num[j]<10)continue;
             num[j+1]+=num[j]/10;
             num[j]%=10;
             num[0]+=(j==num[0]);
        }
    }
    for (int i=1;i<=num[0];i++){
        printf("%d",num[num[0]-i+1]);
        sum+=num[i];
    }
    printf("\n");
    printf("%d\n",sum);
    return 0;
}
```





## EP18

### 题目

By starting at the top of the triangle below and moving to adjacent  numbers on the row below, the maximum total from top to bottom is 23.

**3**
**7** 4
 2 **4** 6
 8 5 **9** 3

That is, 3 + 7 + 4 + 9 = 23.

Find the maximum total from top to bottom of the triangle below:

75
 95 64
 17 47 82
 18 35 87 10
 20 04 82 47 65
 19 01 23 75 03 34
 88 02 77 73 07 63 67
 99 65 04 28 06 16 70 92
 41 41 26 56 83 40 80 70 33
 41 48 72 33 47 32 37 16 94 29
 53 71 44 65 25 43 91 52 97 51 14
 70 11 33 28 77 73 17 78 39 68 17 57
 91 71 52 38 17 14 91 43 58 50 27 29 48
 63 66 04 68 89 53 67 30 73 16 69 87 40 31
 04 62 98 27 23 09 70 98 73 93 38 53 60 04 23

**NOTE:** As there are only 16384 routes, it is possible to solve this problem by trying every route. However, [Problem 67](https://projecteuler.net/problem=67),  is the same challenge with a triangle containing one-hundred rows; it  cannot be solved by brute force, and requires a clever method! ;o)

### 思路

DP题。自底向上和自顶向下两种DP方式。用矩阵保存当前最优的路径。

### 代码

```c

#include<stdio.h>

#define MAX_N 15

int map[MAX_N+5][MAX_N+5];
int keep[MAX_N+5][MAX_N+5]={0};

int solve(int i,int j){
    if (i==MAX_N) return 0;
    if (keep[i][j]) return keep[i][j];
    int l=solve(i+1,j),r=solve(i+1,j+1);
    keep[i][j]=(l>r?l:r)+map[i][j];
    return keep[i][j];
}

int main(){
    for (int i=0;i<MAX_N;i++){
        for (int j=0;j<=i;j++){
            scanf("%d",&map[i][j]);
        }
    }

    printf("%d\n",solve(0,0));

    return 0;
}
```





## EP20

### 题目

*n*! means *n* × (*n* − 1) × ... × 3 × 2 × 1

For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.

Find the sum of the digits in the number 100!

### 思路

大整数乘法。

### 代码

```c

#include<stdio.h>
#define MAX_N 1000
#define DIGIT 100
int fac[MAX_N+5]={1,1};
int main(){
    for (int i=2;i<=DIGIT;i++){
        for (int j=1;j<=fac[0];j++){
            fac[j]*=i;
        }
        //两个循环不能合一，否则乘法结果会错误
        for (int j=1;j<=fac[0];j++){//标准进位处理
            if (fac[j]<10) continue;
            fac[j+1]+=fac[j]/10;
            fac[j]%=10;
            fac[0]+=(j==fac[0]);

        }
    }

    int sum=0;
    for (int i=1;i<=fac[0];i++){
        sum+=fac[i];
    }
    printf("%d\n",sum);
    return 0;
}
```





## EP22

###　题目

Using [names.txt](https://projecteuler.net/project/resources/p022_names.txt)  (right click and 'Save Link/Target As...'), a 46K text file containing  over five-thousand first names, begin by sorting it into alphabetical  order. Then working out the alphabetical value for each name, multiply  this value by its alphabetical position in the list to obtain a name  score.

For example, when the list is sorted into alphabetical order, COLIN,  which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list.  So, COLIN would obtain a score of 938 × 53 = 49714.

What is the total of all the name scores in the file?

### 思路

重点在于用C++的sort函数排序，string类型的length是不包括结束符的长度，abc的length值为３，所以循环是<length即可。大字符串数据的引入可以用字符串数组完成。

### 代码

```c

#include<stdio.h>
#include "ep22.h"
#include <algorithm>
#include <inttypes.h>
using namespace std;
int main(){
    int64_t i=0,sum=0;
    while (nameList[i++].length()!=0);
    sort(nameList,nameList+i-1);
    i=0;
    while (nameList[i].length()!=0){
        int person=0;
        for (int j=0;j<nameList[i].length();j++){
            person+=nameList[i][j]-'A'+1;
        }
        i++;
        sum+=person*i;
    }
    printf("%"PRId64"\n",sum);
    return 0;
}

```





## EP24

### 题目

A permutation is an ordered arrangement of objects. For example, 3124  is one possible permutation of the digits 1, 2, 3 and 4. If all of the  permutations are listed numerically or alphabetically, we call it  lexicographic order. The lexicographic permutations of 0, 1 and 2 are:

012   021   102   120   201   210

What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?

### 思路

全排序问题。不熟练，**复习**。

1. 用C++的next_permutation与prev_permutation完成全排列。效率低。
2. 每位数字每跳一次，需要增加n!次次序，所以可以用计算得出各个位数。

### 代码

```c

#include<stdio.h>
#define MAX_N 10

//重点在于要有找规律的技巧，有行动序列是一种状态的意识


int jnum[MAX_N]={0};//储存阶乘
int dnum[MAX_N]={0};//记录使用过的数字,1代表未用过，0代表已用

void init(){
    jnum[0]=dnum[0]=1;
    for (int i=1;i<MAX_N;i++){
        dnum[i]=1;
        jnum[i]=i*jnum[i-1];
    }
}

int judge_num(int n,int k){
    int index=(k/jnum[n])+1,i=-1;//k/jnum[n]+1代表当前位置跳的个数
    while (index>0){
        i++;
        index-=dnum[i];//按顺序找到往后跳至位置的数字，用i记录（index为跳跃次数，i为下标，也为数字本身）
    }
    dnum[i]=0;//标记为用过
    return i;
}

int main(){
    init();
    int n,k;//有n个数，找第k个状态
    scanf("%d %d",&n,&k);
    k--;//第k个状态，代表着从第1个开始往后跳k-1个状态
    for (int i=n-1;i>=0;i--){//i代表剩余几个数，k代表还要跳几个状态
        int num=judge_num(i,k);//找状态函数，返回第n-i个数
        printf("%d",num);
        k%=jnum[i];
    }
    printf("\n");
    return 0;
}
```





## EP26

### 题目

A unit fraction contains 1 in the numerator. The decimal  representation of the unit fractions with denominators 2 to 10 are  given:

> | 1/2  | =    | 0.5        |
> | ---- | ---- | ---------- |
> | 1/3  | =    | 0.(3)      |
> | 1/4  | =    | 0.25       |
> | 1/5  | =    | 0.2        |
> | 1/6  | =    | 0.1(6)     |
> | 1/7  | =    | 0.(142857) |
> | 1/8  | =    | 0.125      |
> | 1/9  | =    | 0.(1)      |
> | 1/10 | =    | 0.1        |

Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.

Find the value of *d* < 1000 for which 1/*d* contains the longest recurring cycle in its decimal fraction part.

### 思路

因为构成循环节的余数是固定的，所以只要在数组中标记余数(商不必记录)，重复的时候即构成循环节。注意：标记使用过的余数时，**记录余数出现时的长度**，因为循环节不一定出现在开头，所以返回值时需要用记录的总长度减去循环节出现的第一个数的长度。**复习**。

### 代码

```c

#include<stdio.h>
#include <string.h>
#define MAX_N 1000

int dnum[MAX_N+5]={0};

int get_length(int d){
    int y=1,n=1;
    memset(dnum,0,sizeof(dnum));
    while (y!=0&&dnum[y]==0){
        dnum[y]=n;//先算10/d,所以先标记1
        y=y*10%d;//先标记在计算，否则下次循环直接不为0跳出
        printf("d=%d,dnum%d=%d\n",d,y,dnum[y]);
        n++;
    }
    return y==0?0:n-dnum[y];
}


int main(){
    int max_length=0,ans=0;
    for (int d=2;d<MAX_N;d++){
        int temp_length=get_length(d);
        if (max_length<temp_length){
            max_length=temp_length;
            ans=d;
        }
    }
    printf("%d\n",ans);


    return 0;
}
```





## EP29

### 题目

Consider all integer combinations of *a**b* for 2 ≤ *a* ≤ 5 and 2 ≤ *b* ≤ 5:

> 2^2=4, 2^3=8, 2^4=16, 2^5=32
>  3^2=9, 3^3=27, 3^4=81, 3^5=243
>  4^2=16, 4^3=64, 4^4=256, 4^5=1024
>  5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by *a**b* for 2 ≤ *a* ≤ 100 and 2 ≤ *b* ≤ 100?

### 思路

暴力就完事了，建立大数数组存储大数的结果，每算出一个值就在结果集里查一遍，没找到就加进去。

### 代码

```c

#include<stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_N 10000//最多100*100个数字
#define MAX_M 210//每个数最多201位



//memcmp返回1表示不同，返回0表示相通，与strcmp类似
//calloc申请空间默认值为0

int *result[MAX_N];//结果集合
int result_length=0;//结果数

int find_result(int *num){
    for (int i = 0; i < result_length; i++){//挨个比较，找到返回第几个
        if (memcmp(result[i], num, sizeof(int) * MAX_M)) continue;
        return i + 1;//功能上返回1也行，返回第几个更有适用性
    }
    return 0;
}


int *cal_num(int a,int b){
    int *temp=(int *)calloc(sizeof(int),MAX_M);//用calloc默认值为0
    temp[0]=temp[1]=1;//初始化
    for (int i = 0;i < b;i++){//大数乘法
        for (int j = 1; j <= temp[0]; j++){
            temp[j] *= a;
        }
        for (int j = 1; j <= temp[0]; j++){//标准进位处理
            if (temp[j] < 10) continue;
            temp[j + 1] += temp[j] /10;
            temp[j] = temp[j] % 10;
            temp[0] += (j==temp[0]);
        }
    }
    return temp;
}

int main(){
    for (int a = 2;a <= 100; a++){
        for (int b = 2;b <= 100;b++){
            int *temp = cal_num(a,b);
            if (find_result(temp)==0){//没找到，添加进结果集
                result[result_length++]=temp;
            }else{
                free(temp);//如果找到了则释放多申请的空间
            }
        }
    } 
    printf("%d\n",result_length);
    return 0;
} 
```





## EP39

### 题目

If *p* is the perimeter of a right angle triangle with integral length sides, {*a*,*b*,*c*}, there are exactly three solutions for *p* = 120.

{20,48,52}, {24,45,51}, {30,40,50}

For which value of *p* ≤ 1000, is the number of solutions maximised?

### 思路

直角三角形问题，用素勾股数。注意：勾股数公式能构造勾股数，但不是所有勾股数都能被构造。所以先求出素勾股数，然后标记素勾股数的倍数。(素勾股数的判定可以用gcd或数组计数器)

### 代码

```c

#include<stdio.h>
#include <math.h>

int used[1005] = {0};

int main(){
    int ans = 0,max_num=0;
    for (int i = 1; i*i <1000; i++){
        for (int j = i+1; 2*i*j<= 1000; j++){
            int a = 2 * i *j;
            int b = j*j - i*i;
            int c = j*j + i*i;
            if (a+b+c > 1000) continue;
            if (used[a+b+c])  continue;
            int k = 1;
            while (k*(a+b+c)<=1000){
                used[k*(a+b+c)]++;
                if (used[k*(a+b+c)]>max_num)｛
                    max_num = used[k*(a+b+c)];
                    ans =k*( a + b +c);
                }    
                k++;
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```





## EP42

### 题目

The *n*th term of the sequence of triangle numbers is given by, *tn* = ½*n*(*n*+1); so the first ten triangle numbers are:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

By converting each letter in a word to a number corresponding to its  alphabetical position and adding these values we form a word value. For  example, the word value for SKY is 19 + 11 + 25 = 55 = *t*10. If the word value is a triangle number then we shall call the word a triangle word.

Using [words.txt](https://projecteuler.net/project/resources/p042_words.txt)  (right click and 'Save Link/Target As...'), a 16K text file containing  nearly two-thousand common English words, how many are triangle words?

### 思路

判断单词值的和是否为三角形数。判断三角形数用二分法。大量字符串数据输入用头文件处理。注意二分查找时三角形数的值可能会越界。

### 代码

```c

#include<stdio.h>
#include <string.h>
#include "ep42.h"


int triangle(int n){
    return n*(n+1)/2;
}

int binary_search(int k){
    int head = 0,tail = 10000, mid;
    while (head <= tail){
        mid = (head + tail) /2;
        if (triangle(mid) == k) return mid;
        if (triangle(mid) < k) head = mid + 1;
        else tail = mid -1;
    }

    return 0;
}

int main(){
    int ans = 0,len = strlen(word[0]), sum = 0, i = 1;
    while (len){
        sum = 0;
        for (int j = 0; j < len; j++){
            sum += word[i][j] - 'A' + 1;
        }

        if (binary_search(sum)){
            printf("word=%s,sum = %d\n",word[i],sum);
            ans ++;
        }
        len = strlen(word[++i]);
    }
    printf("%d\n",ans);
    return 0;
}
```





## EP46

### 题目

It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.

9 = 7 + 2×1^2
 15 = 7 + 2×2^2
 21 = 3 + 2×3^2
 25 = 7 + 2×3^2
 27 = 19 + 2×2^2
 33 = 31 + 2×1^2

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?

### 思路

可以用数组标记符合条件的数字。也可以用二分法查找2×n^2。

### 代码

```c

#include<stdio.h>
#include <math.h>
#include <inttypes.h>
#define MAX_N 100000


int prime[MAX_N + 5]={0};
int used[MAX_N + 5] = {0};
void init(){
    for (int i = 2; i <=MAX_N; i++){
        if (!prime[i]){
            prime[++prime[0]] = i;
            used[i] = 1;
        }
        for (int j = 1; j <= prime[0] && i*prime[j] <= MAX_N;j++){
            prime[i*prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
    return;

}
int main(){
    init();
    for (int i = 1;i <= prime[0]; i++){
        for (int j = 1;;j++){
            if (prime[i]+2*j*j > MAX_N) break;
            used[prime[i]+2*j*j] = 1;
        }
    }
    for (int i = 9; i<=MAX_N; i+=2){
        if (used[i]) continue;
        printf("%d\n",i);
        break;
    }
    return 0;
}
```





## EP47

### 题目

The first two consecutive numbers to have two distinct prime factors are:

14 = 2 × 7
15 = 3 × 5

The first three consecutive numbers to have three distinct prime factors are:

644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.

Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?

### 思路

找到第一个连续三个数有四个不同的素因子。求素因子数，使用**线性筛框架**，若*i%prime[j]==0*，则i  * prime[j]因子数等于i的因子数，否则因子数为i的因子数加1。因为素数从小开始找，所以因子不会重复。线性筛框架，**复习。**

### 代码

```c

#include<stdio.h>
#define MAX_N 1000000

int prime[MAX_N+5] = {0};
int dnum[MAX_N+5]={0};

void init(){
    for (int i = 2;i<=MAX_N;i++){
        if (!prime[i]){
            prime[++prime[0]] = i;
            dnum[i]=1;
        }
        for (int j = 1;j<=prime[0]&&i*prime[j]<=MAX_N;j++){
            prime[i*prime[j]] = 1;
            if (i%prime[j]==0) {
                dnum[i*prime[j]]=dnum[i];
                break;
            }
            else{
                dnum[i*prime[j]] = dnum[i] + 1;
            }
        }
    }
}

int main(){
    init();
    for (int i = 1;i<=MAX_N-3;i++){
        if (dnum[i]!=4) continue;
        if (dnum[i+1]!=4) continue;
        if (dnum[i+2]!=4) continue;
        if (dnum[i+3]!=4) continue;
        printf("%d\n",i);
        break;
    }
    return 0;
}
```





## EP19

### 题目

You are given the following information, but you may prefer to do some research for yourself.

- 1 Jan 1900 was a Monday.
- Thirty days has September,
   April, June and November.
   All the rest have thirty-one,
   Saving February alone,
   Which has twenty-eight, rain or shine.
   And on leap years, twenty-nine.
- A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.

How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?

### 思路

日期模拟。闰年的判断放在日期的增加中，每增加一日，根据日的变化修改月，再根据月的变化修改年。如果日变为１，则月加1，月变为13，则年加１。加日时，先增加一天，观察是否大于对应月份的天数，并加上闰年判断。**复习**

### 代码

```c
#include<stdio.h>
int days[13] = {
     0,31,28,31,
    30,31,30,31,
    31,30,31,30,31
};

int leap_year(int y){
    return (y % 4 == 0 && y % 100) || (y % 400 == 0);
}

int get_next_date(int y, int m, int d){
     d++;//增加天数
    if (d > days[m] + (m == 2 && leap_year(y))){//判断闰年并重置天数
        d = 1;
    }
    return d;
}

int main(){
    int ans = 0, y = 1900, m = 1, d = 1, w = 1;
    do{
        d = get_next_date(y,m,d);//得到下一天的日期
        m += (d == 1);//如果跨月改月份
        y += (m == 13 &&(m = 1));//如果跨年改年份，闰年判断放在日中
        printf("%d-%d-%d\n",y,m,d);
        w ++;
        w %=7;
        if (w==0 && y > 1900 && d==1) ans++;
    }while (y < 2001);
    printf("%d\n",ans);
    return 0;
}
```

